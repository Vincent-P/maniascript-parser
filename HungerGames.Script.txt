// -------------------------------------- //
//  HUNGER GAMES 3.3.0 by domino54        //
//  script version: 2018-02-17            //
// -------------------------------------- //

#Extends "Modes/ShootMania/ModeGalaxyTitles.Script.txt"

#Const CompatibleMapTypes "HungerGamesV2Arena"
#Const Version		"2018-02-17"
#Const ScriptName	"Modes/ShootMania/HungerGames.Script.txt"

#Include "Libs/Nadeo/ShootMania/Map.Script.txt" as Map
#Include "Libs/domino54/MultiClans.Script.txt" as Clans

// ---------------------------------- //
// Settings
// ---------------------------------- //
#Setting S_OffZoneActivationTime	360		as _("OffZone activation time (0 = don't activate)")
#Setting S_OffZoneShrinkDuration	180		as _("OffZone shrink duration (min. 60)")
#Setting S_ObjectsSpawnRatio		-1.		as _("Objects spawning ratio (-1 = auto)")
#Setting S_NewcomersJoinTime		240		as _("Time for new players to join the game after it starts")
#Setting S_ObjectsDroppingRatio		.5		as _("Objects drop ratio from eliminated players")
#Setting S_RandomizeObjectsSpawns	True	as _("Randomize objects locations on the map (except Armor)")
#Setting S_ArmorRespawnTime			180		as _("Armor and Replie respawn duration (0 = don't respawn)")
#Setting S_ToadsFirstSpawnDelay		30		as _("Delay before Toads are spawned")
#Setting S_AllowPlayersRespawn		True	as _("Allow players to respawn on Checkpoints")
#Setting S_MatchmakingFormat		8		as _("Number of players in matchmaking mode")

/// Overwrite existing settings
#Setting S_AutoManageAFK		False
#Setting S_PlayerArmorPoints	5
#Setting S_MaximumNbWeapons		3
#Setting S_MaximumNbReplies		5
#Setting S_ObjectsRespawnTime	300
#Setting S_ToadsRespawnTime		240
#Setting S_ToadsSpawnRatio		1.

// ---------------------------------- //
// Constants
// ---------------------------------- //
#Const C_ModeSupportedObjects ["Weapon", "Charge", "Mini", "Replie", "Armor", "Fuel"]
#Const C_RequiredPlayersNb			2		///< Minimum number of players required to start the game
#Const C_StartCountdownDuration		10000	///< Duration of the cinematic countdown before game start
#Const C_OffZoneMinShrinkDuration	60		///< Minimum Tornado shrinking duration
#Const C_OffZoneMinimumRadius		36.		///< Minimum radius Tornado is shrinking to
#Const C_AutoRatioItemsPerPlayer	15		///< Amount of items spawned per player with automatic ratio on
#Const C_PlayerMaxNbRocketSlots		4		///< Maximum amount of Rockets held by the player
#Const C_PlayerPointsForSurvival	10		///< Points given for surviving other player elimination
#Const C_PlayerPointsForObjects		1		///< Points given for picking up Weapon, Charge and Mini
#Const C_WinnerMinPointsDiff		10		///< Minimum difference in amount of winner points to next player
#Const C_WeaponItemArmorBonus		100		///< Armor healed when picking up Weapon item
#Const C_ChargeItemSkillPoints		5		///< Additional skill points given by the Charge item
#Const C_MiniItemBonusMultiplier	2		///< Mini item multiplier of regular Charge bonus
#Const C_MiniItemArmorTakenOnPick	100		///< Amont of player armor removed on picking up Mini
#Const C_ObjectsDropSpreadRadius	1.		///< Maximum distance items can be spawned from player upon elimination
#Const C_ToadObjectDropChance		.25		///< Chance for a Toad to drop Charge
#Const C_ToadChanceForArmorDrop		.25		///< Chance that item dropped by Toad will be Armor
#Const C_GateOpeningDuration		5000	///< Required standing time for a Gate to open
#Const C_GateAutoCloseDelay			7500	///< Time after which the Gate closes again
#Const C_CheckpointSafeDistance		12.		///< Tornado distance for a Checkpoint to become unavailable to respawn at
#Const C_RespawnWaitingDuration		15000	///< Time the player needs to wait to respawn
#Const C_RespawnCancellingSpeed		2.5		///< Cancel respawn request if the player reaches this speed

#Const Description _("TYPE: Free for all\nOBJECTIVE: Protect Pole from Toads attack as long as it's possible. Game is over when 20 Toads reach the Pole.")

/// Amount of weapons players get for touching the pole
#Const C_PlayerInitialWeapons [
	CSmMode::EWeapon::Laser => 0,
	CSmMode::EWeapon::Nucleus => 0,
	CSmMode::EWeapon::Arrow => 0,
	CSmMode::EWeapon::Rocket => 4
]

/// Players skills settings
#Const C_SkillsPointsStart	["AmmoGain" => 0, "StaminaGain" => 0, "StaminaMax" => 75]
#Const C_SkillsPointsOnGoal	["AmmoGain" => 50, "StaminaGain" => 20]
#Const C_SkillsPointsLimit	["AmmoGain" => 300, "StaminaGain" => 100, "StaminaMax" => 300]

/// Position of the scores table depending on the statistics visibility
#Const C_ScoresTablePosition [False => <0., 40., 20.>, True => <0., 47., 20.>]

// ---------------------------------- //
// Global variables
// ---------------------------------- //
declare Boolean G_IsOffZoneActivated;	///< Tells if the Tornado is active or not
declare Text[] G_SpawnedPlayers;	///< List of all players who were spawned during the map
declare Text[] G_LoginsTouchedGoal;	///< Players, who have touched the central Goal
declare Ident[] G_CreatedObjects;	///< Objects created by the game mode
declare Vec3 G_CenterGoalPosition;	///< Position of the central Goal landmark
declare Ident[] G_RespawnLandmarks;	///< Ids of all landmarks on which the player can respawn
declare Ident[Text] G_ObjectId;	///< Ids of the loaded objects used by the mode
declare Ident[] G_SpawnsList;	///< List of Spawns available to toss
declare Ident G_LatestSpawnId;	///< Previously tossed Spawn

// ---------------------------------- //
// Extend
// ---------------------------------- //
***Match_LogVersions***
***
Log::RegisterScript(ScriptName, Version);
Log::RegisterScript(Map::GetScriptName(), Map::GetScriptVersion());
***

// ---------------------------------- //
// Set up matchmaking
// ---------------------------------- //
***MM_SetupMatchmaking***
***
declare Integer[] MatchmakingFormats;
for (I, 1, S_MatchmakingFormat) MatchmakingFormats.add(1);
MM_SetFormat(MatchmakingFormats);
***

// ---------------------------------- //
// Scores table
// ---------------------------------- //
***ScoresTable***
***
TopScores::RemoveCategory("Support");
TopScores::AddCategory("Items", "Found items", "", 1., "", 2.25, 60.);
TopScores::AddCategory("Survival", "Survived kills", "", 2., "", 2.25, 75.);
TopScores::SetFormat(3, 1);

ST2::SetPlayerCardImages(" ", C_ImgBase^"STPlayerLeft.png", C_ImgBase^"STPlayerRight.png");
ST2::SetColWidth("LibST_SMPoints", 5.);
ST2::DestroyCol("LibST_SMRoundPoints");
***

// ---------------------------------- //
// Update the mode rules
// ---------------------------------- //
***Match_Rules***
***
ModeInfo::SetName("Hunger Games");
ModeInfo::SetType(ModeInfo::C_Type_FreeForAll);
ModeInfo::SetRules("1. You have only one life per map.\n2. At the very beginning of the map, you must activate your skills by touching the Goal.\n3. To get more weapons and develop your character abilities, search and pick up items on the map.\n4. If you are eliminated, you will spectate the rest of the map.\n5. The last player alive wins the game.");
ModeInfo::SetStatusMessage(Description);
***

// ---------------------------------- //
// Galaxy settings
// ---------------------------------- //
***GalaxyTitles_Settings***
***
GT_UseAutoEndSequence = False;
GT_UseAutospawnObjects = False;
GT_UseComboWeapons = False;
GT_UseRandomToads = False; ///< Toads are initialized later manually
GT_AutoManageOnRespawn = False;
GT_AutoManageOnObjectTouch = False;
GT_KillfeedTranslations = ["$<%1$> is now playing in Games", "$<%1$> tried to escape arena"];
GT_CharactersDataFileURL = "";
***

// ---------------------------------- //
// Init server
// ---------------------------------- //
***Match_InitServer***
***
MM_EnableMatchReconnect(False);

// Load objects
G_ObjectId["Weapon"]	= ItemList_Add("HungerGames\\Weapon.Item.Gbx");
G_ObjectId["Charge"]	= ItemList_Add("HungerGames\\Charge.Item.Gbx");
G_ObjectId["Mini"]		= ItemList_Add("HungerGames\\Mini.Item.Gbx");

// Create custom interfaces
// UIManager.UIAll.SpectatorForceCameraType = 0; ///< Disables the free-cam ("Cam 7")
Layers::Create("HungerGames:Interface", CreateManialinkInterface());
Layers::Create("HungerGames:Statistics", CreateManialinkStatistics());
Layers::SetType("HungerGames:Statistics", CUILayer::EUILayerType::ScoresTable);

// Variables
declare PrevTimeLimit = S_OffZoneActivationTime;
declare PrevPlayersNbAlive = PlayersNbAlive;
declare SpawnedToads = False;
declare OffZoneRadiusMax = 0.;
***

// ---------------------------------- //
// Map start
// ---------------------------------- //
***Match_InitMap***
***
PauseMenu::SetQuitButtonAvailable(True);
ST2::SetFooterText(TL::Compose("%1 -", _("Remaining players: ")));
UIResetAll();
UISetStartTime(-1);
DestroyAllObjects();

// ---------------------------------- //
// Check if the map is valid
declare CenterGoalLandmarkId = NullId;
declare CenterGoal <=> Map::GetLandmarkSector("Goal", 0);
declare MapValidated = CenterGoal != Null && MapLandmarks_PlayerSpawn.count > 0;

// Skip map if not valid
if (!MapValidated) GT_SkipInvalidMap();
***

// ---------------------------------- //
// Initialize the map objects
// ---------------------------------- //
***InitializeObjects***
***
// ---------------------------------- //
// Reset objects landmarks
foreach (MapLandmark in MapLandmarks_ObjectAnchor) {
	declare Boolean ObjectSpawned for MapLandmark;
	declare Integer ObjectNextSpawn for MapLandmark;
	declare Text ObjectType for MapLandmark;
	ObjectSpawned = False;
	ObjectNextSpawn = -1;
	ObjectType = "";
}

// ---------------------------------- //
// Check how many objects are on map
declare NbObjectsSpawnLandmarks = Integer[Text];
declare TotalNbObjectsSpawns = 0;

foreach (MapLandmark in MapLandmarks_ObjectAnchor) {
	if (!C_ModeSupportedObjects.exists(MapLandmark.Tag)) continue;
	if (!NbObjectsSpawnLandmarks.existskey(MapLandmark.Tag)) NbObjectsSpawnLandmarks[MapLandmark.Tag] = 0;
	NbObjectsSpawnLandmarks[MapLandmark.Tag] += 1;
	TotalNbObjectsSpawns += 1;
}

// ---------------------------------- //
// Get the target objects amount ratio
declare ObjectsSpawnRatio = ML::Clamp(S_ObjectsSpawnRatio, 0., 1.);
if (S_ObjectsSpawnRatio < 0) {
	declare TargetObjectsAmount = C_AutoRatioItemsPerPlayer * Players.count;
	ObjectsSpawnRatio = ML::Min(ML::ToReal(TargetObjectsAmount) / TotalNbObjectsSpawns, 1.);
}

// ---------------------------------- //
// Get target amount of every object to spawn
declare AvailableObjectsTags = C_ModeSupportedObjects;
declare CurrentObjectTag = AvailableObjectsTags[0];
declare NbObjectsToSpawn = Integer[Text];
declare TotalNbObjectsToSpawn = 0;

while (TotalNbObjectsToSpawn < TotalNbObjectsSpawns * ObjectsSpawnRatio) {
	if (TotalNbObjectsSpawns <= 0) break;
	
	// Initialize tag in array if doesn't exist
	if (!NbObjectsToSpawn.existskey(CurrentObjectTag)) NbObjectsToSpawn[CurrentObjectTag] = 0;
	
	// Go to the next item type if there is enough of current one
	if (
		!NbObjectsSpawnLandmarks.existskey(CurrentObjectTag) ||
		NbObjectsToSpawn[CurrentObjectTag] >= NbObjectsSpawnLandmarks[CurrentObjectTag] * ObjectsSpawnRatio
	) {
		declare Removed = AvailableObjectsTags.remove(CurrentObjectTag);
		if (AvailableObjectsTags.count <= 0) break;
		
		CurrentObjectTag = AvailableObjectsTags[0];
		continue;
	}
	
	// Increase the amount of object
	NbObjectsToSpawn[CurrentObjectTag] += 1;
	TotalNbObjectsToSpawn += 1;
}

// ---------------------------------- //
// Create list of available object landmarks per item type
declare Ident[] AvailableLandmarksIds;
declare CSmMapLandmark[][Text] AvailableLandmarksOfType;

foreach (MapLandmark in MapLandmarks_ObjectAnchor) {
	if (!AvailableLandmarksOfType.existskey(MapLandmark.Tag)) AvailableLandmarksOfType[MapLandmark.Tag] = CSmMapLandmark[];
	AvailableLandmarksOfType[MapLandmark.Tag].add(MapLandmark);
	if (MapLandmark.Tag != "Armor") AvailableLandmarksIds.add(MapLandmark.Id);
}

// ---------------------------------- //
// Choose random landmarks spawning Armor and other items, if not randomized
foreach (Type => ObjectAmount in NbObjectsToSpawn) {
	if (!AvailableLandmarksOfType.existskey(Type)) continue;
	if (S_RandomizeObjectsSpawns && Type != "Armor") continue;
	declare CurObjectSelectedLandmarks = 0;
	
	while (CurObjectSelectedLandmarks < ObjectAmount) {
		if (AvailableLandmarksOfType[Type].count <= 0) break;
		
		declare MapLandmark <=> AvailableLandmarksOfType[Type][ML::Rand(0, AvailableLandmarksOfType[Type].count - 1)];
		declare Removed = AvailableLandmarksOfType[Type].remove(MapLandmark);
		CurObjectSelectedLandmarks += 1;
		
		if (MapLandmark != Null) {
			declare Text ObjectType for MapLandmark;
			ObjectType = Type;
		}
	}
}

// ---------------------------------- //
// Choose randomized positions for items other than Armor, if enabled
if (S_RandomizeObjectsSpawns) foreach (Type => ObjectAmount in NbObjectsToSpawn) {
	if (Type == "Armor") continue;
	declare CurObjectSelectedLandmarks = 0;
	
	while (CurObjectSelectedLandmarks < ObjectAmount) {
		if (AvailableLandmarksIds.count <= 0) break;
		
		declare MapLandmarkId = AvailableLandmarksIds[ML::Rand(0, AvailableLandmarksIds.count - 1)];
		declare Removed = AvailableLandmarksIds.remove(MapLandmarkId);
		CurObjectSelectedLandmarks += 1;
		
		if (MapLandmarks.existskey(MapLandmarkId)) {
			declare MapLandmark <=> MapLandmarks[MapLandmarkId];
			declare Text ObjectType for MapLandmark;
			ObjectType = Type;
		}
	}
}
***

// ---------------------------------- //
// Round start
// ---------------------------------- //
***Match_StartRound***
***
UIManager.UIAll.UISequence = CUIConfig::EUISequence::None;
Interfancy::SetModuleVisibility("Countdown", False);
UISetNbPlayersAlive(0);
MiniMap::Hide();

// Matchmaking: don't allow substitutes and disable penalty
if (MM_IsMatchServer()) {
	MM_AllowSubstitutes(False);
	MM_EnablePenalty(False);
}

// ---------------------------------- //
// Reset global variables
G_IsOffZoneActivated = False;
G_SpawnedPlayers.clear();
G_LoginsTouchedGoal.clear();
G_RespawnLandmarks.clear();
G_SpawnsList.clear();
G_LatestSpawnId = NullId;
SpawnedToads = False;

// ---------------------------------- //
// Init OffZone
OffZoneRadiusMax = 0.;
OffZoneRadiusSpeed = 0.;
OffZoneRadius = 0.;

// ---------------------------------- //
// Initialize the central Goal
if (CenterGoal != Null) {
	UIManager.UIAll.SpectatorForcedTarget = CenterGoal.Id;
	CenterGoalLandmarkId = CenterGoal.Id;
	CenterGoal.Gauge.ValueReal = 1.;
	CenterGoal.Gauge.Captured = True;
	
	G_CenterGoalPosition = CenterGoal.Position;
	MiniMap::SetMarker("Goal", "Goal.png", Vec3, G_CenterGoalPosition);
}

// ---------------------------------- //
// Get landmarks distances to the central Goal
foreach (MapLandmark in MapLandmarks) {
	if (MapLandmark.Id == CenterGoalLandmarkId) continue;
	declare Real CenterGoalDistance for MapLandmark;
	CenterGoalDistance = GT_Distance2D(MapLandmark.Position, G_CenterGoalPosition);
}

// ---------------------------------- //
// Configure Gate landmarks
foreach (MapLandmark in MapLandmarks_Gate) {
	MapLandmark.Gate.AutoOpenSpeed = 1;
	MapLandmark.Gate.AutoCloseDelay = C_GateAutoCloseDelay;
	MapLandmark.Gate.Clan = 1;
	MapLandmark.Gauge.Max = C_GateOpeningDuration;
}

// ---------------------------------- //
// Get the respawnable Checkpoints landmarks
foreach (MapLandmark in MapLandmarks_Gauge)
	if (MapLandmark.Tag == "Checkpoint") G_RespawnLandmarks.add(MapLandmark.Id);

// ---------------------------------- //
// Wait for enough players to start the game
UIManager.UIAll.BigMessage = _("Waiting for players...");
while (!ServerShutdownRequested && !MatchEndRequested && (Players.count < C_RequiredPlayersNb || CupAdmin::IsCupPaused())) MB_Yield();
UIManager.UIAll.BigMessage = "";

// Reset UI
foreach (Player in AllPlayers) {
	UISetPlayerSurvivedPosition(Player, 0);
}

// ---------------------------------- //
// Initialize objects
---InitializeObjects---

// ---------------------------------- //
// Begin match
Layers::Attach("HungerGames:Interface");
UIManager.UIAll.UISequence = CUIConfig::EUISequence::EndRound;
StartTime = Now + C_StartCountdownDuration + 1000;
UISetStartTime(StartTime);
StoragePlayer::SetCountdown(StartTime, 10000);

// Set the Tornado activation countdown
if (S_OffZoneActivationTime <= 0) UIManager.UIAll.CountdownEndTime = -1;
else UIManager.UIAll.CountdownEndTime = StartTime + S_OffZoneActivationTime * 1000;

// Setup interface
Layers::Attach("HungerGames:Statistics");
ST2::SetPos(C_ScoresTablePosition[True]);
ST2::Build("SM");
***

// ---------------------------------- //
// Start play loop
// ---------------------------------- //
***Match_StartPlayLoop***
***
MiniMap::Hide();

// ---------------------------------- //
// Spawn players for the game
foreach (Player in Players) HG_SpawnPlayer(Player);
PrevPlayersNbAlive = PlayersNbAlive;
UISetNbPlayersAlive(PlayersNbAlive);
ST2::SetFooterText(TL::Compose("%1 "^PlayersNbAlive, _("Remaining players: ")));
***

// ---------------------------------- //
// On armor empty
// ---------------------------------- //
***OnArmorEmpty***
***
// ---------------------------------- //
// Drop the player objects
if (!Event.Victim.IsBot && PlayersNbAlive > 2) {
	DropPlayerObjects(Event.Victim, S_ObjectsDroppingRatio);
	if (MMCommon::IsMatchServer()) UISetPlayerSurvivedPosition(Event.Victim, PlayersNbAlive + 1);
}

// ---------------------------------- //
// Chance for Toads to drop an item
if (Event.Victim.IsBot && Event.Shooter != Null && C_ToadObjectDropChance > 0 && ML::Rand(0., 1.) <= C_ToadObjectDropChance) {
	declare NewObjectTag = "Charge";
	
	// Small chance for item to be Armor
	if (Event.Shooter.Armor < Event.Shooter.ArmorMax && ML::Rand(0., 1.) <= C_ToadChanceForArmorDrop) NewObjectTag = "Armor";
	
	declare Object = SpawnObject(Event.Victim.Position, NewObjectTag);
}
***

// ---------------------------------- //
// On player touches object
// ---------------------------------- //
***OnPlayerTouchesObject***
***
Discard(Event);

// Ignore all events caused by bots and players who haven't touched the goal
if (Event.Player.IsBot || !G_LoginsTouchedGoal.exists(Event.Player.Login)) continue;

// Cache Tag and AnchorId, as it gets destroyed with object
declare Ident AnchorId for Event.Object;
declare Text Tag for Event.Object;
declare ObjectAnchorId = AnchorId;
declare ObjectTag = Tag;

// Pick up the object
declare PickedUpObject = GalaxyTitles::PickUpObject(Event, True);
if (!PickedUpObject) PickedUpObject = PickUpObject(Event);

// ---------------------------------- //
// Start item respawn timer
if (PickedUpObject && MapLandmarks_ObjectAnchor.existskey(ObjectAnchorId)) {
	declare MapLandmark <=> MapLandmarks_ObjectAnchor[ObjectAnchorId];
	declare Boolean ObjectSpawned for MapLandmark;
	declare Integer ObjectNextSpawn for MapLandmark;
	
	declare FasterRespawnObjects = ["Armor", "Fuel", "Replie"];
	declare RespawnDuration = S_ObjectsRespawnTime;
	if (FasterRespawnObjects.exists(ObjectTag)) RespawnDuration = S_ArmorRespawnTime;
	
	ObjectSpawned = RespawnDuration <= 0;
	ObjectNextSpawn = Now + RespawnDuration * 1000;
}
***

// ---------------------------------- //
// On hit event
// ---------------------------------- //
***OnHitConditions***
***
if (Clans::AreTeammates(Event.Shooter, Event.Victim)) {
	Discard(Event);
	continue;
}
***

***OnHit***
***
declare Boolean PlayerRequestsRespawn for Event.Victim;
declare Integer PlayerRespawnStartTime for Event.Victim;

// ---------------------------------- //
// Stop respawn request
if (PlayerRequestsRespawn) {
	Translations::SendStatusMessage(Event.Victim, "Respawn aborted: you've taken damage!", 3000, 0);
	PlayerRequestsRespawn = False;
	PlayerRespawnStartTime = -1;
	UISetRespawnStartTime(Event.Victim, -1);
}
***

// ---------------------------------- //
// On shoot event
// ---------------------------------- //
***OnShoot***
***
declare Boolean PlayerRequestsRespawn for Event.Shooter;
declare Integer PlayerRespawnStartTime for Event.Shooter;

// ---------------------------------- //
// Stop respawn request
if (PlayerRequestsRespawn) {
	Translations::SendStatusMessage(Event.Shooter, "Respawn aborted: you started attacking", 3000, 0);
	PlayerRequestsRespawn = False;
	PlayerRespawnStartTime = -1;
	UISetRespawnStartTime(Event.Shooter, -1);
}
***

// ---------------------------------- //
// Play loop
// ---------------------------------- //
***Match_PlayLoop***
***
// Spawn the objects (only after players are spawned)
if (Now >= StartTime) SpawnObjects();

// ---------------------------------- //
// Manage events
foreach (Event in PendingEvents) {
	// ---------------------------------- //
	// Player touching goal
	if (Event.Type == CSmModeEvent::EType::OnPlayerTriggersSector) {
		declare LandmarkId = NullId;
		foreach (MapLandmark in MapLandmarks_Sector) if (MapLandmark.Sector == Event.Sector) LandmarkId = MapLandmark.Id;
		if (LandmarkId != CenterGoalLandmarkId) continue;
		
		// Register the Goal touch
		if (G_LoginsTouchedGoal.exists(Event.Player.Login)) continue;
		G_LoginsTouchedGoal.add(Event.Player.Login);
		Event.Player.HasShield = True;
		
		// Set the player skills
		foreach (SkillType => SkillPoints in C_SkillsPointsOnGoal)
			SetPlayerSkill(Event.Player, SkillType, SkillPoints);
		
		// Set player weapons
		foreach (Weapon => Amount in C_PlayerInitialWeapons) Inventory::SetWeaponSlots(Event.Player, Weapon, Amount);
		UIAddPlayerTouchingGoal(Event.Player.User.Login);
	}
	// ---------------------------------- //
	// On player request respawn
	else if (Event.Type == CSmModeEvent::EType::OnPlayerRequestRespawn) {
		declare Boolean PlayerRequestsRespawn for Event.Player;
		declare Integer PlayerRespawnStartTime for Event.Player;
		
		// ---------------------------------- //
		// Cancel ongoing respawn request
		if (PlayerRequestsRespawn) {
			PlayerRequestsRespawn = False;
			PlayerRespawnStartTime = -1;
			UISetRespawnStartTime(Event.Player, -1);
		}
		
		// Respawn is disabled by the server
		else if (!S_AllowPlayersRespawn)
			Translations::SendStatusMessage(Event.Player, "Respawn is not allowed on this server", 3000, 0);
		
		// Player must touch the Goal first
		else if (!G_LoginsTouchedGoal.exists(Event.Player.Login))
			Translations::SendStatusMessage(Event.Player, "You must touch the Goal before respawning!", 3000, 0);
		
		// No checkpoints available for respawn
		else if (G_RespawnLandmarks.count <= 0)
			Translations::SendStatusMessage(Event.Player, "No respawn Checkpoints available on map!", 3000, 0);
		
		// ---------------------------------- //
		// Start new respawn request
		else {
			PlayerRequestsRespawn = True;
			PlayerRespawnStartTime = Now;
			UISetRespawnStartTime(Event.Player, Now);
		}
		
		// Always discard the event
		Discard(Event);
	}
}

// ---------------------------------- //
// Disable cinematic stripes and show minimap
if (Now >= StartTime - 1500 && UIManager.UIAll.UISequence != CUIConfig::EUISequence::Playing) {
	Interfancy::SetModuleVisibility("Countdown", Now < UIManager.UIAll.CountdownEndTime);
	UIManager.UIAll.UISequence = CUIConfig::EUISequence::Playing;
	UIManager.UIAll.SpectatorForcedTarget = NullId;
	MiniMap::Show();
}

// ---------------------------------- //
// Tornado is not active yet
if (!G_IsOffZoneActivated) {
	// ---------------------------------- //
	// Update current Tornado activation time limit
	if (PrevTimeLimit != S_OffZoneActivationTime) {
		PrevTimeLimit = S_OffZoneActivationTime;
		
		if (S_OffZoneActivationTime <= 0) UIManager.UIAll.CountdownEndTime = -1;
		else UIManager.UIAll.CountdownEndTime = StartTime + (S_OffZoneActivationTime * 1000);
		Interfancy::SetModuleVisibility("Countdown", Now >= StartTime - 1500 && Now < UIManager.UIAll.CountdownEndTime);
	}
	
	// ---------------------------------- //
	// Initialize Toads
	if (S_ToadsFirstSpawnDelay >= 0 && !SpawnedToads && Now >= StartTime + S_ToadsFirstSpawnDelay * 1000) {
		GalaxyTitles::InitToads(S_ToadsSpawnRatio);
		SpawnedToads = True;
	}
	
	// ---------------------------------- //
	// Start the Tornado
	if (Now > StartTime && S_OffZoneActivationTime > 0 && (PlayersNbAlive <= 2 || Now >= UIManager.UIAll.CountdownEndTime)) {
		G_IsOffZoneActivated = True;
		UIManager.UIAll.CountdownEndTime = -1;
		
		// ---------------------------------- //
		// Compute the initial OffZone radius
		declare MapCorners = [<0., 0., 0.>, <384., 0., 0.>, <0., 0., 384.>, <384., 0., 384.>];
		foreach (CornerPosition in MapCorners) {
			declare Distance = GT_Distance2D(G_CenterGoalPosition, CornerPosition);
			if (Distance > OffZoneRadiusMax) OffZoneRadiusMax = Distance;
		}
		
		// ---------------------------------- //
		// Start the OffZone
		declare OffZoneShrinkDuration = ML::Max(S_OffZoneShrinkDuration, C_OffZoneMinShrinkDuration);
		OffZoneCenterLandmarkId = CenterGoalLandmarkId;
		OffZoneRadiusSpeed = (OffZoneRadiusMax - C_OffZoneMinimumRadius) / OffZoneShrinkDuration;
		OffZoneRadius = OffZoneRadiusMax;
		
		// ---------------------------------- //
		// Start decreasing the pole gauge
		CenterGoal.Gauge.Max = OffZoneShrinkDuration * 1000;
		CenterGoal.Gauge.Value = CenterGoal.Gauge.Max;
		CenterGoal.Gauge.Speed = -1;
		
		// Send notice
		Message::SendStatusMessage(_("Tornado activated."), 4000, 1, CUIConfig::EUISound::Notice, 0);
		Interfancy::SetModuleVisibility("Countdown", False);
	}
}
// ---------------------------------- //
// Tornado is active
else if (OffZoneRadius > 0) {
	// ---------------------------------- //
	// Stop the Tornado
	if (OffZoneRadius <= C_OffZoneMinimumRadius) {
		OffZoneRadius = C_OffZoneMinimumRadius;
		OffZoneRadiusSpeed = 0.;
		CenterGoal.Gauge.ValueReal = 0.;
	}
	
	// ---------------------------------- //
	// Destroy objects behind Tornado
	declare Ident[] ObjectsToDestroy;
	foreach (Object in Objects) {
		declare Real CenterGoalDistance for Object;
		if (CenterGoalDistance >= OffZoneRadius && !ObjectsToDestroy.exists(Object.Id)) ObjectsToDestroy.add(Object.Id);
	}
	while (ObjectsToDestroy.count > 0) {
		declare Boolean Removed;
		Removed = DestroyObject(Objects[ObjectsToDestroy[0]]);
		Removed = ObjectsToDestroy.removekey(0);
	}

	// ---------------------------------- //
	// Manage landmarks
	foreach (MapLandmark in MapLandmarks) {
		if (MapLandmark.Id == CenterGoalLandmarkId) continue;
		declare Real CenterGoalDistance for MapLandmark;
		if (CenterGoalDistance <= 0) continue;

		// ---------------------------------- //
		// Turn off Bases behind the Tornado
		if (MapLandmark.Base != Null && MapLandmark.Base.IsActive && CenterGoalDistance >= OffZoneRadius)
			MapLandmark.Base.IsActive = False;
		
		// ---------------------------------- //
		// Make the Gates open as fast as close the Tornado is
		if (MapLandmark.Gate != Null && MapLandmark.Gate.Automatic) {
			// ---------------------------------- //
			// Open the Gate when behind the Tornado
			if (CenterGoalDistance >= OffZoneRadius) {
				MapLandmark.Gate.Automatic = False;
				MapLandmark.Gate.ManualClosed = False;
				MapLandmark.Gauge.ValueReal = 0.;
			}
			// ---------------------------------- //
			// Compute the Gate opening duration
			else {
				declare TornadoDistance = OffZoneRadius - CenterGoalDistance;
				declare TornadoDistanceMax = OffZoneRadiusMax - CenterGoalDistance;
				MapLandmark.Gauge.Max = ML::FloorInteger(C_GateOpeningDuration * TornadoDistance / TornadoDistanceMax);
			}
		}
		
		// ---------------------------------- //
		// Remove respawn Checkpoint close to the Tornado
		if (
			MapLandmark.Gauge != Null && G_RespawnLandmarks.exists(MapLandmark.Id) &&
			CenterGoalDistance >= OffZoneRadius - C_CheckpointSafeDistance
		) {
			declare Removed = G_RespawnLandmarks.remove(MapLandmark.Id);
		}
	}
}

// ---------------------------------- //
// Manage players functions
foreach (Player in Players) {
	// ---------------------------------- //
	// A new player joins the game after start
	if (!G_SpawnedPlayers.exists(Player.User.Login)) {
		if (!G_IsOffZoneActivated && S_NewcomersJoinTime > 0 && Now - StartTime <= S_NewcomersJoinTime * 1000) {
			HG_SpawnPlayer(Player);
			if (Now > StartTime) Killfeed::SendNotice(["$<%1$> is now playing in Games", Player.User.Name]);
		}
		else {
			G_SpawnedPlayers.add(Player.Login);
			Translations::SendChat(Player, "You came too late to join this match. Please wait for the next map. Good luck!");
		}
	}
	
	// ---------------------------------- //
	// Unspawn players trying to escape arena
	if (Player.SpawnStatus == CSmPlayer::ESpawnStatus::Spawned) {
		declare IsOutsideArena = False;
		for (I, 0, 2) if (I != 1 && (Player.Position[I] < 0 || Player.Position[I] > 384)) IsOutsideArena = True;
		if (Player.Position.Y < -50) IsOutsideArena = True;

		// ---------------------------------- //
		// Eliminate player
		if (IsOutsideArena) {
			// Notify everyone about elimination and drop player objects
			if (PlayersNbAlive >= 2) {
				Killfeed::SendNotice(["$<%1$> tried to escape arena", Player.User.Name]);
				DropPlayerObjects(Player, S_ObjectsDroppingRatio);
			}
			UnspawnPlayer(Player);
		}
	}
	
	// ---------------------------------- //
	// Respawning players on checkpoints
	declare Boolean PlayerRequestsRespawn for Player;
	declare Integer PlayerRespawnStartTime for Player;
	declare StopRespawnRequest = False;
	
	if (PlayerRequestsRespawn) {
		// ---------------------------------- //
		// Cancel respawn if the player is not spawned anymore
		if (Player.SpawnStatus != CSmPlayer::ESpawnStatus::Spawned) StopRespawnRequest = True;
		
		// ---------------------------------- //
		// Successfully respawn the player
		else if (Now >= PlayerRespawnStartTime + C_RespawnWaitingDuration) {
			// ---------------------------------- //
			// Get nearest player distance for all Checkpoints 
			declare Real[Ident] LandmarksDistances;
			foreach (MapLandmark in MapLandmarks_Gauge) {
				if (!G_RespawnLandmarks.exists(MapLandmark.Id)) continue;
				declare NearestPlayerDistance = 0.;
				foreach (Player2 in Players) if (Player2.SpawnStatus == CSmPlayer::ESpawnStatus::Spawned) {
					declare Distance = ML::Distance(Player2.Position, MapLandmark.Position);
					if (NearestPlayerDistance <= 0 || Distance < NearestPlayerDistance) NearestPlayerDistance = Distance;
				}
				if (NearestPlayerDistance > 0) LandmarksDistances[MapLandmark.Id] = -NearestPlayerDistance;
			}
			
			// ---------------------------------- //
			// Respawn the player on the Checkpoint furthest from any players
			LandmarksDistances = LandmarksDistances.sort();
			foreach (MapLandmarkId => Distance in LandmarksDistances) {
				RespawnPlayer(Player, MapLandmarks[MapLandmarkId]);
				break;
			}
			
			PlayerRequestsRespawn = False;
			PlayerRespawnStartTime = -1;
		}
		// ---------------------------------- //
		// Cancel respawn if the player has moved
		else if (Player.Speed >= C_RespawnCancellingSpeed) {
			Translations::SendStatusMessage(Player, "Respawn aborted: you moved!", 3000, 0);
			StopRespawnRequest = True;
		}
		// ---------------------------------- //
		// Cancel request if all Checkpoints are behind Tornado
		else if (G_RespawnLandmarks.count <= 0) {
			Translations::SendStatusMessage(Player, "Respawn aborted: no respawn Checkpoints avaliable anymore", 3000, 0);
			StopRespawnRequest = True;
		}
	}
	
	// ---------------------------------- //
	// Stop respawn request
	if (StopRespawnRequest) {
		PlayerRequestsRespawn = False;
		PlayerRespawnStartTime = -1;
		UISetRespawnStartTime(Player, -1);
	}
}

// ---------------------------------- //
// Update amount of players alive
if (PrevPlayersNbAlive != PlayersNbAlive) {
	ST2::SetFooterText(TL::Compose("%1 "^PlayersNbAlive, _("Remaining players: ")));
	UISetNbPlayersAlive(PlayersNbAlive);

	if (Now > StartTime) {
		// ---------------------------------- //
		// Give survival points to all players alive
		if (PlayersNbAlive < PrevPlayersNbAlive) {
			foreach (Player in Players) {
				if (Player.SpawnStatus != CSmPlayer::ESpawnStatus::Spawned) continue;
				TopScores::AddPoints(Player.Score, "Survival", 1);
				Scores::AddPlayerMapPoints(Player.Score, C_PlayerPointsForSurvival);
			}
			if (PlayersNbAlive >= 2) Message::SendStatusMessage(TL::Compose("%1 "^PlayersNbAlive, _("Remaining players: ")), 4000, 2);
		}
	
		// ---------------------------------- //
		// Play the victory sound
		if (Clans::GetNbAliveClans(True) == 1) {
			UIManager.UIAll.SendNotice(
				"", CUIConfig::ENoticeLevel::Default,
				Null, CUIConfig::EAvatarVariant::Default,
				CUIConfig::EUISound::VictoryPoint, 0
			);
			MB_StopMatch();
		}
	}

	PrevPlayersNbAlive = PlayersNbAlive;
}

// ---------------------------------- //
// Turn round points into actual total points
foreach (Score in Scores) {
	declare RoundPoints = Scores::GetPlayerRoundPoints(Score);
	if (RoundPoints == 0) continue;

	Scores::AddPlayerMapPoints(Score, RoundPoints);
	Scores::SetPlayerRoundPoints(Score, 0);
}

// Victory conditions
if (Now > StartTime && PlayersNbAlive <= 1) MB_StopMatch();
***

// ---------------------------------- //
// Map end
// ---------------------------------- //
***Match_EndMap***
***
Layers::Detach("HungerGames:Interface");
Interfancy::SetModuleVisibility("Countdown", False);
UISetNbPlayersAlive(0);
UISetStartTime(-1);
DestroyAllObjects();
MiniMap::DestroyMarker("Goal");

OffZoneRadiusSpeed = 0.;
OffZoneRadius = 0.;
if (CenterGoal != Null) CenterGoal.Gauge.Speed = 0;

// ---------------------------------- //
// Set the map winner
declare WinnerId = NullId;
foreach (Player in Players) {
	if (PlayersNbAlive != 1) break;
	if (Player.SpawnStatus != CSmPlayer::ESpawnStatus::Spawned) continue;
	WinnerId = Player.Id;

	// ---------------------------------- //
	// Minimum points for winner
	declare MinTargetScore = 0;
	foreach (Score in Scores) {
		if (Score == Player.Score) continue;
		declare MapPoints = Scores::GetPlayerMapPoints(Score);
		if (MapPoints > MinTargetScore) MinTargetScore = MapPoints;
	}

	declare WinnerMapPoints = Scores::GetPlayerMapPoints(Player.Score);
	declare Difference = WinnerMapPoints - MinTargetScore;

	if (Difference <= 0) {
		Scores::SetPlayerMapPoints(Player.Score, MinTargetScore + C_WinnerMinPointsDiff);
	} else if (Difference < C_WinnerMinPointsDiff) {
		Scores::AddPlayerMapPoints(Player.Score, C_WinnerMinPointsDiff - Difference);
	}

	break;
}

// Disallow the winner to move after match end
UIManager.UIAll.UISequence = CUIConfig::EUISequence::UIInteraction;
MB_Sleep(1500);

// Cinematic round end
UIManager.UIAll.UISequence = CUIConfig::EUISequence::EndRound;
MB_Sleep(1500);

// ---------------------------------- //
// Revert the interface
Layers::Detach("HungerGames:Statistics");
ST2::SetPos(C_ScoresTablePosition[False]);
ST2::Build("SM");

declare Text WinnerName;
if (Players.existskey(WinnerId)) WinnerName = Players[WinnerId].User.Name;

// ---------------------------------- //
// Display the round winner
UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::ForcedVisible;
UIManager.UIAll.BigMessageSound = CUIConfig::EUISound::EndRound;
UIManager.UIAll.BigMessageSoundVariant = 0;

if (WinnerName == "") UIManager.UIAll.BigMessage = _("|Match|Draw");
else UIManager.UIAll.BigMessage = TL::Compose(_("$<%1$> wins the match!"), WinnerName);

MB_Sleep(6000);

// ---------------------------------- //
// Podium
UIManager.UIAll.UISequence = CUIConfig::EUISequence::Podium;
while(!UIManager.UIAll.UISequenceIsCompleted) MB_Yield();

UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::Normal;
UIManager.UIAll.BigMessage = "";
***

// ---------------------------------- //
// Server end
// ---------------------------------- //
***Match_EndServer***
***
Layers::Destroy("HungerGames:Interface");
Layers::Destroy("HungerGames:Statistics");
***

// ---------------------------------- //
// Functions
// ---------------------------------- //

// ---------------------------------- //
/** Update skills of a player
 *
 *	@param	_Player		The player to update
 */
Void UpdatePlayerSkills(CSmPlayer _Player) {
	if (_Player == Null) return;
	declare Integer[Text] PlayerSkillPoints for _Player;
	
	// ---------------------------------- //
	// Limit skill points
	foreach (SkillType => SkillPoints in C_SkillsPointsLimit) {
		if (!PlayerSkillPoints.existskey(SkillType)) continue;
		PlayerSkillPoints[SkillType] = ML::Min(PlayerSkillPoints[SkillType], SkillPoints);
	}
	
	// ---------------------------------- //
	// Apply skill points to the player parameters
	foreach (SkillType => SkillPoints in PlayerSkillPoints) switch (SkillType) {
		case "AmmoGain"		: _Player.AmmoGain		= ML::Clamp(SkillPoints / 100., 0., 10.);
		case "StaminaGain"	: _Player.StaminaGain	= ML::Clamp(SkillPoints / 100., 0., 1.);
		case "StaminaMax"	: _Player.StaminaMax	= ML::Clamp(SkillPoints / 100., .1, 3.);
	}
}

// ---------------------------------- //
/** Set specific skill points of a player
 *
 *	@param	_Player			The player to set skill points
 *	@param	_SkillType		Type of the skill to set
 *	@param	_SkillPoints	Amount of the skill points to set
 */
Void SetPlayerSkill(CSmPlayer _Player, Text _SkillType, Integer _SkillPoints) {
	if (_Player == Null || _SkillType == "") return;
	
	declare Integer[Text] PlayerSkillPoints for _Player;
	PlayerSkillPoints[_SkillType] = ML::Max(0, _SkillPoints);
	
	UpdatePlayerSkills(_Player);
}

// ---------------------------------- //
/** Add specific skill points for a player
 *
 *	@param	_Player			The player to add skill points
 *	@param	_SkillType		Type of the skill to add
 *	@param	_SkillPoints	Amount of the skill points to add
 */
Void AddPlayerSkill(CSmPlayer _Player, Text _SkillType, Integer _SkillPoints) {
	if (_Player == Null || _SkillType == "") return;
	
	declare Integer[Text] PlayerSkillPoints for _Player;
	if (!PlayerSkillPoints.existskey(_SkillType)) PlayerSkillPoints[_SkillType] = 0;
	PlayerSkillPoints[_SkillType] += ML::Max(0, _SkillPoints);
	
	UpdatePlayerSkills(_Player);
}

// ---------------------------------- //
/** Initialize and spawn a player
 *
 *	@param	_Player		A Player to spawn
 */
Void HG_SpawnPlayer(CSmPlayer _Player) {
	if (_Player == Null || _Player.User == Null || G_SpawnedPlayers.exists(_Player.User.Login)) return;
	
	// ---------------------------------- //
	// Initialize through mode base and enable all weapon slots
	GT_InitPlayer(_Player);
	Inventory::SetAvailableWeapons(_Player, [
		CSmMode::EWeapon::Laser,
		CSmMode::EWeapon::Nucleus,
		CSmMode::EWeapon::Arrow,
		CSmMode::EWeapon::Rocket
	]);
	Inventory::SetFirstWeapon(_Player);
	SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Rocket, 0);
	
	// ---------------------------------- //
	// Reset variables
	declare Text[] ObjectsToDrop for _Player;
	ObjectsToDrop.clear();
	
	// Initialize player skills
	foreach (SkillType => SkillPoints in C_SkillsPointsStart)
		SetPlayerSkill(_Player, SkillType, SkillPoints);
	
	// ---------------------------------- //
	// Melee spawn selection method
	if (G_SpawnsList.count == 0) foreach (MapLandmark in MapLandmarks_PlayerSpawn) G_SpawnsList.add(MapLandmark.Id);
	declare SpawnId = NullId;
	while (True) {
		SpawnId = G_SpawnsList[ML::Rand(0, G_SpawnsList.count - 1)];
		if (SpawnId != G_LatestSpawnId) break;
		if (G_SpawnsList.count == 1) break;
	}
	G_LatestSpawnId = SpawnId;
	declare Removed = G_SpawnsList.remove(SpawnId);
	
	// Spawn the player
	SM::Spawn(_Player, 0, MapLandmarks_PlayerSpawn[SpawnId].PlayerSpawn);
	G_SpawnedPlayers.add(_Player.Login);
	_Player.HasShield = False;
}

// ---------------------------------- //
/** Spawn an object
 *
 *	@param	_Position	The position the object will be created at
 *	@param	_ObjectTag	Type of the object to create
 *	@param	_AnchorId	Id of the map landmark object is spawned on
 *
 *	@return		The created object
 */
CSmObject SpawnObject(Vec3 _Position, Text _ObjectTag, Ident _AnchorId) {
	if (_Position == <0., 0., 0.> || !C_ModeSupportedObjects.exists(_ObjectTag)) return Null;

	// Check if the given id belongs to a real object anchor landmark
	declare AnchorId = NullId;
	if (MapLandmarks_ObjectAnchor.existskey(_AnchorId)) AnchorId = _AnchorId;
	
	// Object may belong to the GalaxyTitles library
	declare Object = GalaxyTitles::SpawnObject(_Position, _ObjectTag);
	
	// ---------------------------------- //
	// Create the object
	if (Object == Null) {
		switch (_ObjectTag) {
			case "Weapon"	: Object = ObjectCreate(G_ObjectId["Weapon"]);
			case "Charge"	: Object = ObjectCreate(G_ObjectId["Charge"]);
			case "Mini"		: Object = ObjectCreate(G_ObjectId["Mini"]);
		}
		if (Object == Null) return Null;
		
		// Spawn object
		Object.SetPosition(_Position);
	}

	// ---------------------------------- //
	// Set object properties
	declare Ident AnchorId as ObjectAnchorId for Object;
	declare Text Tag for Object;
	ObjectAnchorId = AnchorId;
	Tag = _ObjectTag;
	
	// Save created object id
	G_CreatedObjects.add(Object.Id);
	
	// ---------------------------------- //
	// Save central Goal distance in the object
	declare Real CenterGoalDistance for Object;
	CenterGoalDistance = GT_Distance2D(Object.Position, G_CenterGoalPosition);
	
	return Object;
}

// ---------------------------------- //
/** Spawn an object
 *
 *	@param	_Position	The position the object will be created at
 *	@param	_ObjectTag	Type of the object to create
 *
 *	@return		The created object
 */
CSmObject SpawnObject(Vec3 _Position, Text _ObjectTag) { return SpawnObject(_Position, _ObjectTag, NullId); }

// ---------------------------------- //
/// Spawn objects on landmarks
Void SpawnObjects() {
	foreach (MapLandmark in MapLandmarks_ObjectAnchor) {
		declare ObjectSpawned for MapLandmark = False;
		declare ObjectNextSpawn for MapLandmark = Now;
		declare ObjectType for MapLandmark = "";
		
		// ---------------------------------- //
		// Continue if landmark has object or object can't be spawned
		if (ObjectType == "" || ObjectSpawned || Now < ObjectNextSpawn) continue;
		
		// ---------------------------------- //
		// Create object
		declare Object = SpawnObject(MapLandmark.Position, ObjectType, MapLandmark.Id);
		ObjectSpawned = Object != Null;
	}
}

// ---------------------------------- //
/** Destroy an object
 *
 *	@param	_Object		The object to destroy
 */
Boolean DestroyObject(CSmObject _Object) {
	if (_Object == Null) return False;
	if (GalaxyTitles::DestroyObject(_Object)) return True;
	
	declare Removed = G_CreatedObjects.remove(_Object.Id);
	
	// Destroy object (unspawning the object gives a quiet sound)
	_Object.SetUnspawned();
	ObjectDestroy(_Object);
	return True;
}

// ---------------------------------- //
/// Destroy all objects created in the mode
Void DestroyAllObjects() {
	if (G_CreatedObjects.count <= 0) return;
	foreach (ObjectId in G_CreatedObjects) {
		if (!Objects.existskey(ObjectId)) continue;
		declare Removed = DestroyObject(Objects[ObjectId]);
	}
	G_CreatedObjects.clear();
}

// ---------------------------------- //
/** Pick up object
 *
 *	@param	_Event	The event to proceed
 *
 *	@return		True, if the object was picked up
 */
Boolean PickUpObject(CSmModeEvent _Event) {
	if (
		_Event == Null || _Event.Type != CSmModeEvent::EType::OnPlayerTouchesObject ||
		_Event.Object == Null || _Event.Player == Null || _Event.Player.IsBot ||
		_Event.Player.SpawnStatus != CSmPlayer::ESpawnStatus::Spawned
	) return False;
	
	declare Text Tag for _Event.Object;
	declare Boolean DroppedByPlayer for _Event.Object;
	
	// Manage only Weapons, Charges and Minis
	declare SupportedTags = ["Weapon", "Charge", "Mini"];
	if (!SupportedTags.exists(Tag)) return False;
	
	// ---------------------------------- //
	// Pick conditions
	declare CSmMode::EWeapon[] PossibleWeapons;
	declare CanPickUpObject = True;
	
	switch (Tag) {
		// ---------------------------------- //
		// Weapon conditions
		case "Weapon" : {
			// Add weapons if player haven't maxed them out yet
			foreach (Weapon => A in C_PlayerInitialWeapons) {
				declare WeaponMaxSlots = S_MaximumNbWeapons;
				if (Weapon == CSmMode::EWeapon::Rocket) WeaponMaxSlots = C_PlayerMaxNbRocketSlots;
				if (WeaponMaxSlots <= 0 || Inventory::GetWeaponSlots(_Event.Player, Weapon) < WeaponMaxSlots)
					PossibleWeapons.add(Weapon);
			}
			
			CanPickUpObject = PossibleWeapons.count > 0;
		}
		// ---------------------------------- //
		// Mini conditions
		case "Mini" : CanPickUpObject = DroppedByPlayer || _Event.Player.Armor - C_MiniItemArmorTakenOnPick > 0;
	}
	
	// Continue, if the object can't be picked up
	if (!CanPickUpObject) return False;
	
	// ---------------------------------- //
	// Apply effect
	switch (Tag) {
		// ---------------------------------- //
		// Weapon: gives 1 weapon and reloads 1 armor
		case "Weapon" : {
			declare NewWeapon = PossibleWeapons[ML::Rand(0, PossibleWeapons.count - 1)];
			Inventory::AddWeaponSlots(_Event.Player, NewWeapon, 1);
			
			// Notify player about the new weapon received
			declare WeaponName = TL::Split("::", ""^NewWeapon);
			Interfancy::SendCrosshairNote(_Event.Player, ["+1 %1 ", WeaponName[WeaponName.count - 1]], 2000);
			
			// Heal the player (if object was naturally generated)
			if (!DroppedByPlayer) GalaxyTitles::GivePlayerArmor(_Event.Player, C_WeaponItemArmorBonus);
		}
		// ---------------------------------- //
		// Charge: increase reload, stamina gain and max
		case "Charge" : {
			declare SkillsToIncrease = ["AmmoGain", "StaminaGain", "StaminaMax"];
			foreach (SkillType in SkillsToIncrease)
				AddPlayerSkill(_Event.Player, SkillType, C_ChargeItemSkillPoints);
			
			// Notify player about new abilities
			Interfancy::SendCrosshairNote(
				_Event.Player,
				["+%1% %2 ", TL::ToText(C_ChargeItemSkillPoints), "Skills"],
				2000
			);
		}
		// ---------------------------------- //
		// MiniCharge: double bonus as Charge, removes 1 armor
		case "Mini" : {
			declare SkillsToIncrease = ["AmmoGain", "StaminaGain", "StaminaMax"];
			foreach (SkillType in SkillsToIncrease)
				AddPlayerSkill(_Event.Player, SkillType, C_ChargeItemSkillPoints * C_MiniItemBonusMultiplier);
			
			// Remove player armor (if object was naturally generated)
			if (!DroppedByPlayer) RemovePlayerArmor(_Event.Player, C_MiniItemArmorTakenOnPick, Null, 0);
			
			// Notify player about new abilities
			Interfancy::SendCrosshairNote(
				_Event.Player,
				["+%1% %2 ", TL::ToText(C_ChargeItemSkillPoints * C_MiniItemBonusMultiplier), "Skills"],
				2000
			);
		}
	}
	
	// ---------------------------------- //
	// Bind object tag to a player for eventual late drop
	declare Text[] ObjectsToDrop for _Event.Player;
	ObjectsToDrop.add(Tag);

	// ---------------------------------- //
	// Give points for picking up the item
	TopScores::AddPoints(_Event.Player.Score, "Items", 1);
	Scores::AddPlayerMapPoints(_Event.Player.Score, C_PlayerPointsForObjects);
	
	// Destroy object
	declare Destroyed = DestroyObject(_Event.Object);
	return True;
}

// ---------------------------------- //
/** Drop objects picked up by a player
 *
 *	@param	_Player		The player whoose objects are dropped
 *	@param	_DropRatio	Percentage ratio of the dropped objects
 */
Void DropPlayerObjects(CSmPlayer _Player, Real _DropRatio) {
	if (_Player == Null || _DropRatio <= 0) return;
	
	// ---------------------------------- //
	// Get all objects of the player
	declare Text[] ObjectsToDrop for _Player;
	declare PlayerReplies = Inventory::GetItemAmount(_Player, "LibGalaxyTitles_Replie");
	if (PlayerReplies > 0) for (I, 1, PlayerReplies) ObjectsToDrop.add("Replie");
	declare TotalObjectsCount = ObjectsToDrop.count;
	
	// Remove random objects when there are too many
	while (ObjectsToDrop.count > TotalObjectsCount * _DropRatio) {
		declare Removed = ObjectsToDrop.removekey(ML::Rand(0, ObjectsToDrop.count - 1));
	}
	
	// ---------------------------------- //
	// Spawn player objects
	foreach (NewObjectTag in ObjectsToDrop) {
		declare ObjectPosition = _Player.Position;
		for (I, 0, 1) ObjectPosition[I*2] += ML::Rand(-C_ObjectsDropSpreadRadius, C_ObjectsDropSpreadRadius);
		
		// Create object
		declare Object = SpawnObject(ObjectPosition, NewObjectTag);
		if (Object == Null) continue;
		
		// Indicate that object was dropped by a player
		declare Boolean DroppedByPlayer for Object;
		DroppedByPlayer = True;
	}
}

// ---------------------------------- //
/** Set start time for the UI
 *
 *	@param	_StartTime	The start time
 */
Void UISetStartTime(Integer _StartTime) {
	declare netwrite Integer Net_HungerGames_StartTime for Teams[0];
	Net_HungerGames_StartTime = _StartTime;
}

// ---------------------------------- //
/** Set alive players amount for the UI
 *
 *	@param	_PlayersNbAlive		Amount of alive players
 */
Void UISetNbPlayersAlive(Integer _PlayersNbAlive) {
	declare netwrite Integer Net_HungerGames_PlayersAlive for Teams[0];
	Net_HungerGames_PlayersAlive = _PlayersNbAlive;
}

// ---------------------------------- //
/** Add player who touched Goal to the UI
 *
 *	@param	_Login	Login of the player
 */
Void UIAddPlayerTouchingGoal(Text _Login) {
	declare netwrite Text[] Net_HungerGames_TouchedGoal for Teams[0];
	Net_HungerGames_TouchedGoal.add(_Login);
}

// ---------------------------------- //
/** Set player respawn time on the UI
 *
 *	@param	_Player		The player to set time
 *	@param	_Time		Player respawn start time
 */
Void UISetRespawnStartTime(CSmPlayer _Player, Integer _Time) {
	if (_Player == Null || _Player.IsBot || _Player.User == Null) return;
	declare Login = _Player.User.Login;
	
	// Set respawn start time
	declare netwrite Integer[Text] Net_HungerGames_RespawnStart for Teams[0];
	if (_Time > 0) Net_HungerGames_RespawnStart[Login] = _Time;
	
	// Reset start time
	else if (Net_HungerGames_RespawnStart.existskey(Login)) {
		declare Removed = Net_HungerGames_RespawnStart.removekey(Login);
	}
}

// ---------------------------------- //
/// Clear interfaces
Void UIResetAll() {
	declare netwrite Text[] Net_HungerGames_TouchedGoal for Teams[0];
	declare netwrite Integer[Text] Net_HungerGames_RespawnStart for Teams[0];
	Net_HungerGames_TouchedGoal.clear();
	Net_HungerGames_RespawnStart.clear();
}

// ---------------------------------- //
/** Set player's survived position.
 *
 *	@param	_Player				The player to set position
 *	@param	_SurvivedPosition	The survived position
 */
Void UISetPlayerSurvivedPosition(CSmPlayer _Player, Integer _SurvivedPosition) {
	if (_Player == Null) return;
	declare UI <=> UIManager.GetUI(_Player);
	if (UI == Null) return;

	declare netwrite Integer Net_HungerGames_SurvivedPosition for UI;
	Net_HungerGames_SurvivedPosition = _SurvivedPosition;
}

// ---------------------------------- //
/** Create manialink for the interface module
 *
 *	@return		The interface manialink
 */
Text CreateManialinkInterface() {
	return """
<manialink version="3" name="HungerGames:Interface">
<stylesheet>
	<style class="font" halign="center" valign="center2" textsize="1" textemboss="1" textcolor="FFF" textfont="Eurostile_Bold" />
	<style class="FontM" valign="center2" textemboss="1" textcolor="FFF" textfont="{{{TL::MLEncode("Eurostile")}}}" />
</stylesheet>

<frame id="Frame_RespawnProgress" pos="0 -54 5">
	<frame id="Frame_RespawnProgAnim">
		<label class="font" textsize="3" id="Label_RespawnProgress" opacity="0" />
		<quad pos="0 8" size="12 12" halign="center" valign="center" id="Quad_RespawnProgIcon" opacity="0" />
		<gauge pos="0 -3" size="52 8" halign="center" valign="center" drawbg="0" id="Gauge_RespawnProgress" hidden="1" />
	</frame>
</frame>

<frame id="Frame_Countdown">
	<quad size="40 40" halign="center" valign="center" id="Quad_DigitPri" />
	<quad size="40 40" halign="center" valign="center" id="Quad_DigitSec" />
</frame>

<frame id="Frame_TouchGoal" pos="0 76">
	<label pos="0 2" class="font" textsize="4" textprefix="$T" id="Label_TouchGoalTitle" opacity="0" />
	<label pos="0 -2" class="font" textprefix="$T" id="Label_TouchGoalDesc" opacity="0" />
</frame>

<frame id="Frame_Eliminated" pos="-60 54" hidden="1">
	<label pos="4 -4" class="FontM" textsize="4" textprefix="$t" text="Eliminated!" translate="1" />
	<quad pos="2 -8" size="116 .5" valign="center" bgcolor="FFF" opacity=".5" />

	<!-- Description -->
	<label pos="60 -18" size="116" class="FontM" halign="center" textsize="2" autonewline="1" id="Label_Description" />

	<!-- Footer -->
	<frame id="Frame_BottomButtonsRow" pos="2 -28">
		<quad size="116 .5" valign="center" bgcolor="FFF" opacity=".5" />

		<!-- Resume button -->
		<frame id="Frame_SpectateButton" pos="2 -2">
			<label pos="2 -4" class="FontM" text="" />
			<label pos="8 -4" class="FontM" textsize="2" textprefix="$t" text="Spectate" translate="1" />

			<quad size="55.5 8" bgcolorfocus="FFF" opacity=".125" class="Click" id="Quad_SpectateButtonCard" ScriptEvents="1" />
			<quad size="55.5 8" bgcolor="FFF" opacity=".125" />
		</frame>

		<!-- Quit button -->
		<frame id="Frame_QuitButton" pos="58.5 -2">
			<label pos="2 -4.5" class="FontM" text="" id="Label_QuitButtonIcon" />
			<label pos="8 -4" class="FontM" textsize="2" textprefix="$t" text="Return to lobby" translate="1" id="Label_QuitButtonText" />

			<quad size="55.5 8" bgcolorfocus="FFF" opacity=".125" class="Click" id="Quad_QuitButtonCard" ScriptEvents="1" />
			<quad size="55.5 8" bgcolor="FFF" opacity=".125" id="Quad_QuitButtonBg" />
		</frame>
	</frame>

	<quad size="120 40" bgcolor="000" opacity=".75" />
	<quad size="120 40" style="Bgs1" substyle="BgDialogBlur" opacity="0" />
	<quad pos="-2.5 2.5" size="250 90" scale=".5" style="Bgs1InRace" substyle="BgButtonShadow" />
</frame>

<script><!--
/**
 *	HungerGames: Interface
 */

#Include "TextLib" as TL
#Include "MathLib" as ML

#Const C_MaxCountdownTicks	{{{ML::Max(C_StartCountdownDuration / 1000, 0)}}}
#Const C_PoleAlertDistance	60.
#Const C_RespawnBarImgBase	"file://Media/Manialinks/ShootMania/Common/"
#Const C_DisplayDuration	2000

// ---------------------------------- //
// Main
// ---------------------------------- //
***Main***
***
// ---------------------------------- //
// Load interface elements
declare Quad_DigitPri <=> (Page.GetFirstChild("Quad_DigitPri") as CMlQuad);
declare Quad_DigitSec <=> (Page.GetFirstChild("Quad_DigitSec") as CMlQuad);
declare Label_TouchGoalTitle <=> (Page.GetFirstChild("Label_TouchGoalTitle") as CMlLabel);
declare Label_TouchGoalDesc <=> (Page.GetFirstChild("Label_TouchGoalDesc") as CMlLabel);

/// Respawn progress bar
declare Frame_RespawnProgress <=> (Page.GetFirstChild("Frame_RespawnProgress") as CMlFrame);
declare Frame_RespawnProgAnim <=> (Page.GetFirstChild("Frame_RespawnProgAnim") as CMlLabel);
declare Label_RespawnProgress <=> (Page.GetFirstChild("Label_RespawnProgress") as CMlLabel);
declare Quad_RespawnProgIcon <=> (Page.GetFirstChild("Quad_RespawnProgIcon") as CMlQuad);
declare Gauge_RespawnProgress <=> (Page.GetFirstChild("Gauge_RespawnProgress") as CMlGauge);

// Eliminated screen
declare Frame_Eliminated <=> (Page.GetFirstChild("Frame_Eliminated") as CMlFrame);
declare Label_Description <=> (Page.GetFirstChild("Label_Description") as CMlLabel);

Label_TouchGoalTitle.SetText(ReplaceChars(Translate("Touch the Goal!")));
Label_TouchGoalDesc.SetText(ReplaceChars(Translate("You must touch the Goal to be able to pick up items!")));
Label_Description.SetText(Translate("You've been eliminated - the game is over for you!\nYou may want to spectate rest of the game, if not, use the button below to return to the lobby and find yourself a new match!"));

// ---------------------------------- //
// Netcode
declare netread Integer Net_HungerGames_StartTime for Teams[0];
declare netread Integer Net_HungerGames_PlayersAlive for Teams[0];
declare netread Text[] Net_HungerGames_TouchedGoal for Teams[0];
declare netread Integer[Text] Net_HungerGames_RespawnStart for Teams[0];
declare netread Integer Net_HungerGames_SurvivedPosition for UI;
declare netread Text Net_LibPauseMenu_LobbyJoinLink for Teams[0];

// ---------------------------------- //
// Variables
declare CountdownSound = Audio.CreateSound("{{{C_ImgBase}}}Sounds/CountdownHungerGames.ogg");
declare CountdownTick = -1;
declare CenterGoalPosition = Vec3;
declare TouchGoalAlertVisible = False;
declare RespawnStartTime = -1;
declare RespawnProgressVisible = False;
declare WaitingDuration = {{{C_RespawnWaitingDuration}}};

// Update
declare PrevCountdownTick = CountdownTick;
declare PrevNbPlayersAlive = -1;
declare PrevTouchGoalAlertVisible = False;
declare PrevRespawnProgressVisible = RespawnProgressVisible;
declare PrevSurvivedPosition = 0;

foreach (MapLandmark in MapLandmarks) {
	if (MapLandmark.Gauge != Null && MapLandmark.Tag == "Goal") CenterGoalPosition = MapLandmark.Position;
}
***

// ---------------------------------- //
// Yield
// ---------------------------------- //
***Yield***
***
// ---------------------------------- //
// Manage events
foreach (Event in PendingEvents) {
	// ---------------------------------- //
	// On mouse click
	if (Event.Type == CMlEvent::Type::MouseClick) {
		// Close the window
		if (Event.ControlId == "Quad_SpectateButtonCard") {
			Frame_Eliminated.Hide();
		}

		// Return to the lobby
		else if (Event.ControlId == "Quad_QuitButtonCard") {
			OpenLink(Net_LibPauseMenu_LobbyJoinLink, CMlScript::LinkType::ManialinkBrowser);
		}
	}
	// ---------------------------------- //
	// On mouse over
	else if (Event.Type == CMlEvent::Type::MouseOver) {
		if (Event.Control.HasClass("Click"))
			Audio.PlaySoundEvent(CAudioManager::ELibSound::Focus, 1, 1.);
	}
}

// ---------------------------------- //
// Show the eliminated window
if (PrevSurvivedPosition != Net_HungerGames_SurvivedPosition) {
	PrevSurvivedPosition = Net_HungerGames_SurvivedPosition;

	declare NbPlayersAlive = 0;
	foreach (Player in Players) {
		if (Player.IsBot || Player.SpawnStatus != CSmPlayer::ESpawnStatus::Spawned) continue;
		NbPlayersAlive += 1;
	}

	if (PrevSurvivedPosition > 0 && NbPlayersAlive > 0) Frame_Eliminated.Show();
}

// ---------------------------------- //
// Set "Touch the Goal" message visibility
TouchGoalAlertVisible = GUIPlayer != Null && GameTime >= GUIPlayer.StartTime && GUIPlayer.Armor > 0 && !Net_HungerGames_TouchedGoal.exists(GUIPlayer.Login);

// ---------------------------------- //
// Update alert visibility
if (PrevTouchGoalAlertVisible != TouchGoalAlertVisible) {
	PrevTouchGoalAlertVisible = TouchGoalAlertVisible;
	
	// ---------------------------------- //
	// Show alert
	if (TouchGoalAlertVisible) {
		Label_TouchGoalTitle.RelativePosition_V3.Y = 4.;
		Label_TouchGoalDesc.RelativePosition_V3.Y = 0.;
		Label_TouchGoalTitle.Opacity = 0.;
		Label_TouchGoalDesc.Opacity = 0.;
		AnimMgr.Add(Label_TouchGoalTitle, "<label pos='0 2' opacity='1' />", 125, CAnimManager::EAnimManagerEasing::Linear);
		AnimMgr.Add(Label_TouchGoalDesc, "<label pos='0 -2' opacity='1' />", 125, CAnimManager::EAnimManagerEasing::Linear);
	}
	// ---------------------------------- //
	// Hide alert
	else {
		Label_TouchGoalTitle.RelativePosition_V3.Y = 2.;
		Label_TouchGoalDesc.RelativePosition_V3.Y = -2.;
		Label_TouchGoalTitle.Opacity = 1.;
		Label_TouchGoalDesc.Opacity = 1.;
		AnimMgr.Add(Label_TouchGoalTitle, "<label pos='0 0' opacity='0' />", 125, CAnimManager::EAnimManagerEasing::Linear);
		AnimMgr.Add(Label_TouchGoalDesc, "<label pos='0 -4' opacity='0' />", 125, CAnimManager::EAnimManagerEasing::Linear);
	}
}

// ---------------------------------- //
// Warning about touching the Goal
if (TouchGoalAlertVisible && CenterGoalPosition != <0., 0., 0.>) {
	declare Distance = ML::Distance(CenterGoalPosition, GUIPlayer.Position);
	if (Distance > C_PoleAlertDistance) {
		declare Color = <.5 + .5 * Pulse(Now, 3.), 0., 0.>;
		Label_TouchGoalTitle.TextColor = Color;
		Label_TouchGoalDesc.TextColor = Color;
	} else {
		Label_TouchGoalTitle.TextColor = <1., 1., 1.>;
		Label_TouchGoalDesc.TextColor = <1., 1., 1.>;
	}
}

// ---------------------------------- //
// Get current countdown tick
CountdownTick = (Net_HungerGames_StartTime - GameTime + 1000) / 1000;

// ---------------------------------- //
// Cannon sound upon elimination
if (PrevNbPlayersAlive != Net_HungerGames_PlayersAlive) {
	if (PrevNbPlayersAlive > Net_HungerGames_PlayersAlive && Net_HungerGames_PlayersAlive >= 2 && GameTime > Net_HungerGames_StartTime) {
		Audio.PlaySoundEvent("{{{C_ImgBase}}}Sounds/PlayerEliminated.ogg", 10.);
	}
	PrevNbPlayersAlive = Net_HungerGames_PlayersAlive;
}

// ---------------------------------- //
// Tick update
if (PrevCountdownTick != CountdownTick) {
	PrevCountdownTick = CountdownTick;
	
	// ---------------------------------- //
	// Animate the countdown number on tick change
	if (CountdownTick >= 0 && CountdownTick <= C_MaxCountdownTicks) {
		Quad_DigitPri.ImageUrl = "{{{C_ImgBase}}}Countdown/main_"^CountdownTick^".png";
		Quad_DigitSec.ImageUrl = "{{{C_ImgBase}}}Countdown/sec_"^CountdownTick^".png";
		
		Quad_DigitPri.RelativeScale = 2.;
		Quad_DigitSec.RelativeScale = 1.;
		
		Quad_DigitPri.Opacity = 1.;
		Quad_DigitSec.Opacity = 1.;
		
		AnimMgr.Add(Quad_DigitPri, "<quad scale='1' />", 1000, CAnimManager::EAnimManagerEasing::CircOut);
		AnimMgr.Add(Quad_DigitSec, "<quad scale='1.5' />", 1000, CAnimManager::EAnimManagerEasing::Linear);
		
		AnimMgr.AddChain(Quad_DigitPri, "<quad opacity='0' />", 250, CAnimManager::EAnimManagerEasing::Linear);
		AnimMgr.AddChain(Quad_DigitSec, "<quad opacity='0' />", 250, CAnimManager::EAnimManagerEasing::Linear);
		
		// ---------------------------------- //
		// Manage countdown sound
		if (!CountdownSound.IsPlaying && CountdownTick > 0) CountdownSound.Play();
		declare TargetPlayCursor = ML::ToReal(10 - CountdownTick);
		if (ML::Abs(CountdownSound.PlayCursor - TargetPlayCursor) > .01) CountdownSound.PlayCursor = TargetPlayCursor;
	}
	
	// ---------------------------------- //
	// Match start sound
	if (CountdownTick == 0) PlayUiSound(CMlScriptIngame::EUISound::StartMatch, 1, 1.);
	
	// ---------------------------------- //
	// Stop countdown sound
	if (CountdownSound.IsPlaying && (CountdownTick <= 0 || CountdownTick > 10)) CountdownSound.Stop();
}

// ---------------------------------- //
// Change respawn progress bar visibility
if (GUIPlayer != Null && Net_HungerGames_RespawnStart.existskey(GUIPlayer.User.Login)) {
	RespawnStartTime = Net_HungerGames_RespawnStart[GUIPlayer.User.Login];
}
else if (RespawnStartTime > 0) RespawnStartTime = -1;

RespawnProgressVisible = GUIPlayer != Null && RespawnStartTime > 0 && GameTime - C_DisplayDuration <= RespawnStartTime + WaitingDuration;

if (PrevRespawnProgressVisible != RespawnProgressVisible) {
	PrevRespawnProgressVisible = RespawnProgressVisible;
	Gauge_RespawnProgress.Visible = RespawnProgressVisible;
	
	Frame_RespawnProgAnim.RelativePosition_V3.Y = 0.;
	Label_RespawnProgress.Opacity = 1.;
	declare PositionY = -2.;
	declare Opacity = 0.;
	
	if (RespawnProgressVisible) {
		Frame_RespawnProgAnim.RelativePosition_V3.Y = -PositionY;
		Label_RespawnProgress.Opacity = 0.;
		PositionY = 0.;
		Opacity = 1.;
	}
	
	AnimMgr.Add(Frame_RespawnProgAnim, "<frame pos='0 "^PositionY^"' />", 125, CAnimManager::EAnimManagerEasing::Linear);
	AnimMgr.Add(Label_RespawnProgress, "<label opacity='"^Opacity^"' />", 125, CAnimManager::EAnimManagerEasing::Linear);
	AnimMgr.Add(Quad_RespawnProgIcon, "<quad opacity='"^Opacity^"' />", 125, CAnimManager::EAnimManagerEasing::Linear);
	
	// ---------------------------------- //
	// Play sound
	declare Sound = CAudioManager::ELibSound::ShowMenu;
	if (!RespawnProgressVisible) Sound = CAudioManager::ELibSound::HideMenu;
	Audio.PlaySoundEvent(Sound, 0, 0.);
}

// ---------------------------------- //
// Configure respawn progress bar
if (RespawnProgressVisible) {
	declare TimeUntilRespawn = RespawnStartTime + WaitingDuration - GameTime;
	
	// ---------------------------------- //
	// Set respawn gauge
	Gauge_RespawnProgress.Color = GUIPlayer.User.Color;
	SetGaugeRatio(Gauge_RespawnProgress, 1 - ML::ToReal(TimeUntilRespawn) / WaitingDuration);
	
	// ---------------------------------- //
	// Set respawn icon
	declare IconURL = C_RespawnBarImgBase^"c_goal_shield.dds";
	if (TimeUntilRespawn <= 0) IconURL = C_RespawnBarImgBase^"c_goal_captured.dds";
	Quad_RespawnProgIcon.ImageUrl = IconURL;
	
	// ---------------------------------- //
	// Ser respawn message text
	declare Message = "";
	if (TimeUntilRespawn <= 0) Message = Translate("Respawned!");
	else Message = Translate(["%1 (%2s)", "Respawning...", TL::ToText(ML::CeilingInteger(TimeUntilRespawn / 1000.))]);
	Label_RespawnProgress.Value = Message;
}
***

{{{ManialinkTools::Functions(["Pulse", "SetGaugeRatio", "ReplaceChars"])}}}
{{{Translations::InjectInManialink(["Touch the Goal!", "You must touch the Goal to be able to pick up items!", "Respawning...", "Respawned!", "Return to lobby"])}}}

// ---------------------------------- //
// Main
// ---------------------------------- //
main() {
	---Main---
	while (True) {
		yield;
		---Yield---
	}
}
--></script>
</manialink>""";
}

// ---------------------------------- //
/** Create manialink for the statistics module
 *
 *	@return		The statistics manialink
 */
Text CreateManialinkStatistics() {
	declare WB = "file://Media/Manialinks/ShootMania/Window/";
	return """
<manialink version="3" name="HungerGames:Statistics">
<stylesheet>
	<style class="font" valign="center2" textemboss="1" textcolor="FFF" textsize="1" textfont="Eurostile_Bold" />
</stylesheet>

<framemodel id="FrameModel_StatGauge">
	<label pos="0 3" class="font" halign="center" textsize="3" id="Label_StatValueCur" text="0%" />
	<label pos="-25 2.25" class="font" halign="left" textcolor="888" id="Label_StatValueMin" text="0%" />
	<label pos="25 2.25" class="font" halign="right" textcolor="888" id="Label_StatValueMax" text="0%" />
	<gauge size="54 8" halign="center" valign="center" drawbg="0" id="Gauge_StatProgress" />
	<label pos="0 -3" size="50 0" class="font" halign="center" textprefix="$t" id="Label_StatDescription" text="---" />
</framemodel>

<frame pos="-84 -44.5" valign="center" size="170 28">
	<frameinstance modelid="FrameModel_StatGauge" id="Frame_StatGauge#0" pos="31 -6" />
	<frameinstance modelid="FrameModel_StatGauge" id="Frame_StatGauge#1" pos="84 -6" />
	<frameinstance modelid="FrameModel_StatGauge" id="Frame_StatGauge#2" pos="137 -6" />

	<quad pos="0 36" size="10 50" image="{{{WB}}}BottomLeft.png" colorize="000" />
	<quad pos="10 36" size="148 50" image="{{{WB}}}Bottom.png" colorize="000" />
	<quad pos="158 36" size="10 50" image="{{{WB}}}BottomRight.png" colorize="000" />
</frame>

<script><!--
/**
 *	HungerGames: Statistics
 */

#Include "MathLib" as ML
#Include "TextLib" as TL

#Const C_StatsNames 	["Ammo reload", "Stamina reload", "Stamina max"]
#Const C_StatsMaximum	[3., 1., 3.]

// ---------------------------------- //
// Main
// ---------------------------------- //
***Main***
***
// ---------------------------------- //
// Laod interface elements
declare CMlFrame[] Frame_StatGauges;
for (I, 0, 2) Frame_StatGauges.add((Page.GetFirstChild("Frame_StatGauge#"^I) as CMlFrame));

// ---------------------------------- //
// Variables
declare InterfaceColor = LocalUser.Color;
declare StatsValues = [0., 0., 0.];

/// Update
declare PrevGUIPlayerId = NullId;
declare PrevInterfaceColor = Vec3;
declare PrevStatsValues = [0., 0., 0.];

// ---------------------------------- //
// Setup statistics
foreach (I => Frame in Frame_StatGauges) {
	declare Label_StatDescription <=> (Frame.GetFirstChild("Label_StatDescription") as CMlLabel);
	declare Label_StatValueMin <=> (Frame.GetFirstChild("Label_StatValueMin") as CMlLabel);
	declare Label_StatValueMax <=> (Frame.GetFirstChild("Label_StatValueMax") as CMlLabel);
	
	Label_StatDescription.SetText(ReplaceChars(Translate(C_StatsNames[I])));
	Label_StatValueMin.SetText("0%");
	Label_StatValueMax.SetText(ML::FloorInteger(C_StatsMaximum[I] * 100)^"%");
}
***

// ---------------------------------- //
// Yield
// ---------------------------------- //
***Yield***
***
// ---------------------------------- //
// Update interface on player change
if (GUIPlayer != Null && GUIPlayer.SpawnStatus != CSmPlayer::ESpawnStatus::NotSpawned) {
	if (PrevGUIPlayerId != GUIPlayer.Id) {
		PrevGUIPlayerId = GUIPlayer.Id;
		InterfaceColor = GUIPlayer.User.Color;
	}
} else if (PrevGUIPlayerId != NullId) {
	PrevGUIPlayerId = NullId;
	InterfaceColor = LocalUser.Color;
	StatsValues = [0., 0., 0.];
}

// ---------------------------------- //
// Update the color of the interface
if (PrevInterfaceColor != InterfaceColor) {
	PrevInterfaceColor = InterfaceColor;
	
	foreach (Frame in Frame_StatGauges) {
		declare Label_StatDescription <=> (Frame.GetFirstChild("Label_StatDescription") as CMlLabel);
		declare Gauge_StatProgress <=> (Frame.GetFirstChild("Gauge_StatProgress") as CMlGauge);
		
		Label_StatDescription.TextColor = Brightness(InterfaceColor, 4.);
		Gauge_StatProgress.Color = InterfaceColor;
	}
}

// ---------------------------------- //
// Update current player statistics
if (PrevGUIPlayerId != NullId && GUIPlayer != Null) {
	StatsValues[0] = GUIPlayer.AmmoGain;
	StatsValues[1] = GUIPlayer.StaminaGain;
	StatsValues[2] = GUIPlayer.StaminaMax;
}

// ---------------------------------- //
// Update statistics frames
foreach (I => Frame in Frame_StatGauges) {
	if (!StatsValues.existskey(I) || !PrevStatsValues.existskey(I) || StatsValues[I] == PrevStatsValues[I]) continue;
	PrevStatsValues[I] = StatsValues[I];
	
	// ---------------------------------- //
	// Get frame elements
	declare Label_StatValueCur <=> (Frame.GetFirstChild("Label_StatValueCur") as CMlLabel);
	declare Gauge_StatProgress <=> (Frame.GetFirstChild("Gauge_StatProgress") as CMlGauge);
	
	// ---------------------------------- //
	// Set gauges ratio
	Label_StatValueCur.SetText(ML::NearestInteger(StatsValues[I] * 100)^"%");
	SetGaugeRatio(Gauge_StatProgress, StatsValues[I] / C_StatsMaximum[I]);
}
***

{{{ManialinkTools::Functions(["SetGaugeRatio", "Brightness", "ReplaceChars"])}}}
{{{Translations::InjectInManialink(["Ammo reload", "Stamina reload", "Stamina max"])}}}

// ---------------------------------- //
// Main
// ---------------------------------- //
main() {
	---Main---
	while (True) {
		yield;
		---Yield---
	}
}
--></script>
</manialink>""";
}

